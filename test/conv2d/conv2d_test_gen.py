#!python
#
# Copyright 2018 Codeplay Software Ltd.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use these files except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
#
# Automatically generate the convolution test cases using TensorFlow to provide
# the expected values.

from __future__ import print_function

try:
    # With python3 `zip` returns an iterator, however with python2, use
    # `itertools.izip` instead
    import itertools.izip as zip
except ImportError:
    pass

import re
import itertools
import os
import string

import tensorflow as tf
import numpy as np

WINDOW_LIST = [1, 1, 3, 3, 5, 5, 7, 7, 11, 11]
STRIDE_LIST = [1, 2, 1, 2, 1, 2, 1, 4, 1, 4]
BATCHES = [1, 3]
CHANNELS = [1, 2, 4]
FEATURES = [1, 2, 4]
PADDING_VALUES = ["SAME", "VALID"]
TEST_TYPES = ["forward", "input_backprop", "filter_backprop"]

LICENSE = r"""/*
 * Copyright 2018 Codeplay Software Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use these files except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */"""
COMMENT_TPL = r"""
// DO NOT MODIFY BY HAND
// This file was automatically generated by {scriptname}.
// Results calculated using Tensorflow v{tf_version}."""
INCLUDES = r"""
#include <gtest/gtest.h>

#include "sycldnn/conv2d/launch.h"
#include "sycldnn/conv2d/params.h"
#include "sycldnn/conv2d/sizes.h"

#include "sycldnn/conv2d/helpers/add_padding_to_params.h"

#include "sycldnn/conv2d/selector/direct_selector.h"
#include "sycldnn/conv2d/selector/tiled_selector.h"

#include "test/conv2d/window_stride_fixture.h"

#include "test/types/cartesian_product.h"
#include "test/types/kernel_data_types.h"
#include "test/types/to_gtest_types.h"

#include <CL/sycl.hpp>

#include <algorithm>
#include <vector>"""
DATA_TYPES = r"""
using DataTypeList = sycldnn::types::KernelDataTypes;
using Selectors = sycldnn::types::TypeList<sycldnn::conv2d::DirectSelector,
                                           sycldnn::conv2d::TiledSelector>;
using SNNTypePairs =
    sycldnn::types::CartesianProduct<Selectors, DataTypeList>::type;
using GTestTypePairs = sycldnn::types::ToGTestTypes<SNNTypePairs>::type;"""
TYPED_TEST_CASE_DECL_TPL = r"""
template <typename Pair>
using {test_case} = WindowStrideTest<Pair, {window}, {stride}>;
TYPED_TEST_CASE({test_case}, GTestTypePairs);"""
EIGEN_STATIC_VARS = r"""
namespace {
cl::sycl::default_selector selector{};
}  // namespace
std::unique_ptr<Eigen::QueueInterface> EigenBackendTest::queue_interface_{
    new Eigen::QueueInterface{selector}};
Eigen::SyclDevice EigenBackendTest::device_{
    EigenBackendTest::queue_interface_.get()};
sycldnn::backend::EigenBackend EigenBackendTest::backend_{
    EigenBackendTest::device_};
"""

def get_tensor_data(size, max_val):
    "Get a list of data values to use as input data."
    if max_val < 1:
        return [i for i in range(1, size + 1)]
    else:
        return [(i % max_val) + 1 for i in range(size)]

def get_forward_conv_results(input_shape, filter_shape, stride_shape, padding, max_val):
    """
    Construct and run a Tensorflow graph to compute forward convolution.

    Will create input tensors of the required size filled with values 1, 2,
    3... and use these to compute the convolution for the forward pass.
    Returns the computed values in a numpy array.
    """
    with tf.Graph().as_default():
        total_inp_size = np.product(input_shape)
        total_fil_size = np.product(filter_shape)

        input_vals = get_tensor_data(total_inp_size, max_val)
        filter_vals = get_tensor_data(total_fil_size, max_val)

        inp_tensor = tf.constant(input_vals, shape=input_shape, dtype=np.float64)
        fil_tensor = tf.constant(filter_vals, shape=filter_shape, dtype=np.float64)
        output = tf.nn.conv2d(
            inp_tensor, fil_tensor, strides=stride_shape, padding=padding,
            data_format="NHWC")

        with tf.Session() as sess:
            init = tf.global_variables_initializer()
            sess.run(init)
            sess.graph.finalize()
            return sess.run(output)

def get_input_backprop_conv_results(input_shape, filter_shape, stride_shape, padding, max_val):
    """
    Construct and run a Tensorflow graph to compute input backprop convolution.

    Will create input tensors of the required size filled with values 1, 2,
    3... and use these to compute the convolution for the input backprop pass.
    Returns the computed values in a numpy array.
    """
    with tf.Graph().as_default():
        total_fil_size = np.product(filter_shape)
        filter_vals = get_tensor_data(total_fil_size, max_val)

        inp_tensor = tf.constant(0, shape=input_shape, dtype=np.float64)
        fil_tensor = tf.constant(filter_vals, shape=filter_shape, dtype=np.float64)
        output = tf.nn.conv2d(
            inp_tensor, fil_tensor, strides=stride_shape, padding=padding,
            data_format="NHWC")

        output_shape = output.shape
        total_out_size = np.product(output_shape)
        output_vals = get_tensor_data(total_out_size, max_val)
        out_tensor = tf.constant(output_vals, shape=output_shape, dtype=np.float64)

        inp_size_tensor = tf.constant(input_shape, shape=[len(input_shape)])
        input_backprop = tf.nn.conv2d_backprop_input(
            inp_size_tensor, fil_tensor, out_tensor, strides=stride_shape,
            padding=padding, data_format="NHWC")

        with tf.Session() as sess:
            init = tf.global_variables_initializer()
            sess.run(init)
            sess.graph.finalize()
            return sess.run(input_backprop)

def get_filter_backprop_conv_results(input_shape, filter_shape, stride_shape,
                                     padding, max_val):
    """
    Construct and run a Tensorflow graph to compute filter backprop convolution.

    Will create input tensors of the required size filled with values 1, 2,
    3... and use these to compute the convolution for the filter backprop pass.
    Returns the computed values in a numpy array.
    """
    with tf.Graph().as_default():
        total_inp_size = np.product(input_shape)
        input_vals = get_tensor_data(total_inp_size, max_val)

        inp_tensor = tf.constant(input_vals, shape=input_shape, dtype=np.float64)
        fil_tensor = tf.constant(0, shape=filter_shape, dtype=np.float64)
        output = tf.nn.conv2d(
            inp_tensor, fil_tensor, strides=stride_shape, padding=padding,
            data_format="NHWC")

        output_shape = output.shape
        total_out_size = np.product(output_shape)
        output_vals = get_tensor_data(total_out_size, max_val)
        out_tensor = tf.constant(output_vals, shape=output_shape, dtype=np.float64)

        fil_size_tensor = tf.constant(filter_shape, shape=[len(filter_shape)])
        filter_backprop = tf.nn.conv2d_backprop_filter(
            inp_tensor, fil_size_tensor, out_tensor, strides=stride_shape,
            padding=padding, data_format="NHWC")

        with tf.Session() as sess:
            init = tf.global_variables_initializer()
            sess.run(init)
            sess.graph.finalize()
            return sess.run(filter_backprop)

# To ensure that the tests can be computed exactly, we require that the results
# are contained in the set of values that can be exactly represented by the
# floating point data types. Single precision floating point values can
# represent all integers up to 2^24. If the values would be larger than this,
# then limit the input values to a smaller range of possible values to limit
# the size of the output values.
REQUIRED_MAX = 2**24
def get_result_and_size(conv_fn, in_shape, window, stride, features, padding):
    """
    Use the provided conv_fn to compute a convolution.

    Ensures that the resulting values are less than the REQUIRED_MAX, and if
    not will adjust the maximum value to allow in the input tensors.
    """
    filter_shape = [window, window, in_shape[-1], features]
    stride_shape = [1, stride, stride, 1]
    max_input_val = 2**12
    max_output_val = REQUIRED_MAX + 1
    while max_output_val > REQUIRED_MAX:
        max_input_val /= 2
        output = conv_fn(
            input_shape=in_shape,
            filter_shape=filter_shape,
            stride_shape=stride_shape,
            padding=padding,
            max_val=max_input_val)
        max_output_val = np.max(output)
    return output, max_input_val

SPACE_REGEX = re.compile(r'([0-9]\.?)\s+')
def format_tensor(tensor):
    "Convert a numpy tensor into an initializer list."
    t_str = str(tensor.flatten())
    t_braced = '{' + t_str[1:-1] + '}'
    t_formatted = re.sub(SPACE_REGEX, r'\1, ', t_braced)
    return t_formatted

def get_conv_fn(test_type):
    """
    Get the function which computes the convolution corresponding to the test type.
    """
    if test_type == "forward":
        return get_forward_conv_results
    elif test_type == "input_backprop":
        return get_input_backprop_conv_results
    elif test_type == "filter_backprop":
        return get_filter_backprop_conv_results
    else:
        return None

def to_camel_case(snake_case):
    "Convert a snake_case string to CamelCase."
    return string.capwords(snake_case, '_').replace('_', '')

TEST_CASE_TPL = "{test_type}Window{window}Stride{stride}"
TEST_NAME_TPL = "{padding}{in_s[0]}x{in_s[1]}x{in_s[2]}x{in_s[3]}x{features}"
IN_SHAPE_INIT_TPL = "{{{{ {0[0]}, {0[1]}, {0[2]}, {0[3]} }}}}"
def get_test_lines(test_type, in_shape, window, stride, features, padding):
    """
    Create a list of strings corresponding to the lines in a single test case.

    Uses TensorFlow to compute the expected results for the given parameters,
    and provides the code to call the test fixture to run the test.
    """
    conv_fn = get_conv_fn(test_type)
    output, max_input_val = get_result_and_size(
        conv_fn, in_shape, window, stride, features, padding)
    camel_case_type = to_camel_case(test_type)
    test_case = TEST_CASE_TPL.format(test_type=camel_case_type, window=window,
                                     stride=stride)
    test_name = TEST_NAME_TPL.format(padding=padding, in_s=in_shape,
                                     features=features)
    in_shape_init = IN_SHAPE_INIT_TPL.format(in_shape)
    test_lines = [
        "TYPED_TEST({}, {}) {{".format(test_case, test_name),
        "  using DataType = typename TestFixture::DataType;",
        "  const std::vector<DataType> exp_out = {};".format(format_tensor(output)),
        "  const std::array<int, 4> in_shape = {};".format(in_shape_init),
        "  const int features = {};".format(features),
        "  const auto padding = sycldnn::PaddingMode::{};".format(padding),
        "  const DataType max_input_val = {:.1f};".format(max_input_val),
        "  this->run_{}_test(exp_out, in_shape, features, padding, max_input_val);".format(
            test_type),
        "}"
    ]
    return test_lines

def get_input_sizes(window, stride):
    """
    Want to test with sizes that are:
        a) Divisible by 4
        b) Divisible by 2 but not 4
        c) Not Divisible by 2
    And we also require the sizes to be large enough that there are at least
    two entries in the output tensor, so the minimum size is (window + stride)
    and the other sizes need to be calculated to ensure that the above criteria
    are satisfied.
    """
    start = window + stride
    if start % 2 == 1:
        return [start, start + 1, start + 3]
    else:
        return [start, start + 1, start + 2]

def test_case_for_window_stride(test_type, window, stride):
    """
    Create a list of strings corresponding to separate lines in the full test
    case. The output contains headers, includes, setup and all the tests for
    the test case.
    """
    scriptname = os.path.basename(__file__)
    tf_version = tf.VERSION
    camel_case_type = to_camel_case(test_type)
    test_case = TEST_CASE_TPL.format(test_type=camel_case_type, window=window,
                                     stride=stride)
    output = [
        LICENSE,
        COMMENT_TPL.format(scriptname=scriptname, tf_version=tf_version),
        INCLUDES,
        DATA_TYPES,
        TYPED_TEST_CASE_DECL_TPL.format(test_case=test_case, window=window,
                                        stride=stride),
        EIGEN_STATIC_VARS
    ]
    in_sizes = get_input_sizes(window, stride)
    for in_shape in itertools.product(BATCHES, in_sizes, in_sizes, CHANNELS):
        for feature, padding in itertools.product(FEATURES, PADDING_VALUES):
            output.extend(
                get_test_lines(test_type, in_shape, window, stride, feature, padding))
    return output

FILENAME_TPL = "{test_type}_window{window}_stride{stride}.cc"
def get_test_case_filename(test_type, window, stride):
    "Get filename for test case."
    return FILENAME_TPL.format(test_type=test_type, window=window,
                               stride=stride)
if __name__ == "__main__":
    np.set_printoptions(suppress=True, precision=10, threshold=1000000, linewidth=1000000)

    for window, stride in zip(WINDOW_LIST, STRIDE_LIST):
        for test_type in TEST_TYPES:
           filename = get_test_case_filename(test_type, window, stride)
           output = test_case_for_window_stride(test_type, window, stride)
           with open(filename, 'w') as f:
               f.write('\n'.join(output))
           print("File '{}' written".format(filename))

